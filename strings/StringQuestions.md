1. Есть несколько вариантов создание объекта String:
1 - String s = new String(); - создание пустой строки. - так же конструктор
2 - String s = "Hi there"; - создание строки с ее инициализацией
3 - String[] s = {"hi", "there"} - создание массива строк с инициализацией
4 -  char [] c = {'H', 'i', 't', 'h', 'r', 'e'}
- String s = new String(c) - приведение символов в строку. - это же и конструктор
- String s = new String(c, 1, 3) - так же конструктор который передает 3 символа начиная с 1 элемента.
- String s = "Good day sir"; - Good Day sir - строковый литерал. значения внутри кавычек - являются строковыми литералами. А так же это упрощенная форма создания объекта String.
2. Изменить состояние невозможно. При попытки изменения создается новый объект String. String - final класс от которого нельзя наследоваться.
- В целях безопасности. Строки активно используются при загрузке классов, в сетевых соединениях, соединениях с базой данных.
- В многопоточности: immutable объекты не меняют состояние, поэтому нет сложностей в синхронизации состояния объекта между потоками.
- Вычисление хэшкода один раз.
- Кэширование литералов String и их повторное использование экономит много места в куче
3. Кодировка - это таблица, в которой описывается соответствие определённого символа и числа
- ASCII, UTF-8, EBCDIC
- Никак, java имеет зафиксированную кодировку - unicode. все остальное только при чтении/перезаписи байтов 	String str=new String(s.getBytes(),"UTF-8");
4. Пул строк (String Pool) — это множество строк в Java Heap Memory.
- заносятся при объявлении.
- поместить принудительно можно при помощи String.intern(), Метод internперед созданием объекта String смотрит есть ли этот объект в пуле стрингов и возвращает его. Иначе создается новый объект в пуле.
- ссылку возможно получить при добавлении с помощью метода intern, если это значение уже присутствует в String Pool
- В 1.6 - находился в PermGen. Начиная с 1.7 в Heap
5. Основное отличие в том что StringBuffer,StringBuilder являются Mutable объектами, которые могут быть изменены.
- потокобезопасным является StringBuffer.
- Объекты StringBuilder и StringBuffer, необходимо сравнивать между собой предварительно приведя к строке медотом .toString().equals(.toString());
- Внутри класса String метод equals переопределён, поэтому можно сравнивать строки по значению с помощью equals, а в классе StringBuilder нет.
6. стандарт кодирования символов, включающий в себя знаки почти всех письменных языков мира.  В настоящее время стандарт является преобладающим в Интернете.
7. codePointAt; codePointBefore; codePointCount; indexOf
- для манипуляциями кодировками. т.е. из 1251 в utf-8 и т.д.
---
Regular Expressions.
1. формальный язык поиска и осуществления манипуляций с подстроками в тексте, основанный на использовании метасимволов 
- Символы определяющие производимую операцию.
- Позиция внутри строки, Специальные символы,Обозначение группы, Перечисление, Квантификация 
```
 \\w	буквенно-цифровой символ (включая _)
 \\W	не буквенно-цифровой
 \\d	числовой символ (тоже, что [0-9])
 \\D	нечисловой
 \\s	любой пробел (такой же как [\t\n\r\f])
 \\S	не пробел
 \\h	горизонтальный разделитель. Табуляция, пробел и все символы
в Unicode категории «разделители» (space separator Unicode category)
 \\H	не горизонтальный разделитель
 \\v	вертикальные разделители. новая строка и все символы
«разделители строк» в Unicode
 \\V	не вертикальный разделитель
 ```
 + Ленивые `*?` `??` `+?` `{n,]?`
Жадные `*` `?` `+` `{n,}`
Ревнивые `*+` `?+` `++` `{n,}+`
- они позволяют нам привязать шаблон регулярного выражения к конкретной точке в строк.
2. Pattern - он же шаблон. Mather - соответствие шаблону.
- java.util.regex
`Pattern pattern = Pattern.compile("(\\d+)"`
`Mather mather = pattern.mather("2018 year was not bad. 2019 was bad. 2020 is goddamn bad")`
`while(mather.find()){`
			`sout(mather.group());`
    `}`
В конкретном случае я групирую цифру которые стоят последовательно друг за другом и вывожу их друг за другом. т.е. выводе будет 2018 \n 2019 \n 2020.
3. группа это набор литералов соответствующих требованиям шаблона.
- слева - направо. начиная от 0 элемента
- На позиции 0 будет всё совпадение целиком.
-  `Pattern pattern = Pattern.compile("(\\d+)"`
`Matсher maсther = pattern.matсher("2018 year was not bad. 2019 was bad. 2020 is goddamn bad")`
`while(mather.find()){`
			`sout(matсher.group());`
    `}`
    