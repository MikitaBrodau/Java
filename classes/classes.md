1.**Опишите процедуру инициализации полей класса и полей экземпляра класса. Когда инициализируются поля класса, а когда – поля экземпляров класса. Какие значения присваиваются полям по умолчанию? Где еще в классе полям могут быть присвоены начальные значения?**
 - поля класса являются статическими и они описывают состояние класса. Грубо говоря чертеж следуя которому будут создаваться экземпляры класса. Поля экземпляра класса -  это состояние объекта которое ему присвоено по-умолчанию или инициализировано.
 соответственно инициализация происходит на этапе поля класса в случае если указаны их значения. В другом случае инциализация происходит уже непосредственно при создании экземпляра. 	по умолчанию полям в зависимости от типа данных принадлежат следующие значения:
 ```:
 int      => 0
boolean  => false
double   => 0.0
float    => 0.0
char     => \u0000  - нуль-символ, он же ' '
long     => 0
byte     => 0
```
- В Java инициализатор - это блок кода, который не имеет связанного имени или типа данных и размещается вне какого-либо метода, конструктора или другого блока кода.
Java предлагает два типа инициализаторов, статические и экземпляры инициализаторов.:
```
{
	a = 4;
    	b = 10;
}
```
либо через конструктор, `get` и `set`, либо сразу инициализировать в конструктора.
2. **Дайте определение перегрузке методов. Как вы думаете, чем удобна перегрузка методов? Укажите, какие методы могут перегружаться, и какими методами они могут быть перегружены? Можно ли перегрузить методы в базовом и производном классах? Можно ли private метод базового класса перегрузить public методов производного? Можно ли перегрузить конструкторы, и можно ли при перегрузке конструкторов менять атрибуты доступа у конструкторов?**
- Перегрузка методов - это возможность создавать несколько методов с одинаковым названием, но разными входыми параметрами.
- можно создавать конструкторы/методы с разными входными параметрами. в условиях одного наименования всегда ясна исполняемая функция.
- статические методы могут перегружаться нестатическими и наоборот
- В производном классе разрешается перегружать любые видимые методы, кроме конструктора базового класса.
- private методы в родительском классе ограничены зоной видимости и могут использоваться только внутри классса. соответсвтенно дочерний метод без проблем может перегружаться.
- перегрузка конструктора возможна, изменение артрибута доступа в случае перегрузки тоже доступа.
3. **Объясните, что такое раннее и позднее связывание? Перегрузка – это раннее или позднее связывание? Объясните правила, которым следует компилятор при разрешении перегрузки; в том числе, если методы перегружаются примитивными типами, между которыми возможно неявное приведение или ссылочными типами, состоящими в иерархической связи.**
- Раннее связывание - это когда метод, который будет вызван, известен во время компиляции, например, вызов статического метода.А позднее связывание(оно же динамическое) - Позднее связывание - это когда вызов метода может быть осуществлен только во время выполнения и у компилятора нет информации, чтобы проверить корректность такого вызова.
- Перегрузка это пример раннего связывания.
- никакие два метода из одного класса не могут иметь одинаковые сигнатуры(при этом сигнатура не включает в себя возвращаемый параметр). Выбирается наиболее подходящий метод. Расширяющее преобразование примитивов имеет приоритет над автоупоковкой/распоковкой. Сужающее преобразование примитивов автоматически не выполняется. Когда вызывается метод , количество фактических аргументов (и любых явных аргументов типа) и типы аргументов времени компиляции используются во время компиляции для определения сигнатуры метода, который будет вызван.
4. **Объясните, как вы понимаете, что такое неявная ссылка this? В каких методах эта ссылка присутствует, а в каких – нет, и почему?**
- ключевое слово This используется в методах в случае необходимости манипуляции полями класса. не используется в статических методах.
5. **Что такое финальные поля, какие поля можно объявить со спецификатором final? Где можно инициализировать финальные поля?**
- Недоступные для каких-либо изменений после инициализации, все поля с спецификатором Final являются Immutable. использовать спецификатор Final, можно с любым модификатором доступа.
- Финальные поля инициализируются в конструкторе, внутри класса, внутри логического блока.
6. **Что такое статические поля, статические финальные поля и статические методы. К чему имеют доступ статические методы? Можно ли перегрузить и переопределить статические методы? Наследуются ли статические методы?**
- Поля данных, объявленные в классе как static, являются общими для всех объектов класса и называются переменными **класса**. static final поля являются константами(глобальными переменными).Такие методы являются методами класса, не привязаны ни к какому объекту,
могут оперировать статическими полями класса, ключевое слово `this` в статическом методе употребить нельзя.
- Статические методы могут наследоваться, но не могут быть переопределены.
7. **Что такое логические и статические блоки инициализации? Сколько их может быть в классе, в каком порядке они могут быть размещены и в каком порядке вызываются?**
- Логические блоки чаще всего используются в качестве инициализаторов полей, но могут содержать вызовы методов как текущего класса, так и не принадлежащих ему. статический блок используется для инициализации статических переменных, а "обычный"  - для всех остальных.
- Статический блок вызывается только один раз в одном из двух случаев:
`при первом создании объекта этого класса;`
`при первом обращении к статическим членам этого класса.`
логический блок может использоваться неограниченное колличество раз.
статические блоки вызываются при загрузке класса. Затем вызывается блок иницализации(до конструктора) затем соответственно вызываются конструкторы.
8. **Что представляют собой методы с переменным числом параметров, как передаются параметры в такие методы и что представляет собой такой параметр в методе? Как осуществляется выбор подходящего метода, при использовании перегрузки для методов с переменным числом параметров**
- Метод с переменным числом параметров, подразумевает неоднократную передачу параметра одного типа. Передаются по правилу объявление в сигнатуре метода
`void pachemu (String ... patamu){}` с помощью многоточья. обязательно переменная должна находится в конце передаваемых параметров. Представляет из себя массив соответственно:
``` 
void pachemu (String ... patamu){
	for(int i = 0; i < patamu.length; i++){
    		sout(patamu[i]);// argumenti
    	}
}
```                                    
Метод, который получает аргументы переменной длины, может иметь несколько перегруженных реализаций. Такие реализации отличаются между собой типом получаемых значений.    
9. Чем является класс Object? Перечислите известные вам методы класса  Object, укажите их назначение.
- Класс object является суперклассом, все остальные классы являются производными от объекта object.
- clone, equals, toString, finalize, hashCode, getClass. так же методы для работы с многопоточностью notify, notifyAll, wait
10. Что такое хэш-значение? Объясните, почему два разных объекта могут сгенерировать одинаковые хэш-коды?
-  хеш-код — это целочисленный результат работы метода, которому в качестве входного параметра передан объект(код ячейки памяти в котором находится объект). 
- т.к. хэш-код означается переменной типа int , который равен 4-м байтам, и может помещать числа от -2 147 483 648 до 2 147 483 647. Вероятность возникновения коллизии зависит от используемого алгоритма генерации хеш-кода. Множество объектов мощнее множества хеш-кодов соответственно вероятность колизии растет с количеством объектов.
![](https://eclipsesource.com/wp-content/uploads/2012/09/hashcode-collisions.png)
11. Что такое объект класса Class? Чем использование метода getClass() и последующего сравнения возвращенного значения с Type.class отличается от использования оператора instanceof?
- это производная класса имеющая инициализированные поля.
- InctanceOf проверяет, является ли ссылка слева - экземпляром  типа в правой части, или подтипом. Метод getClass возвращает объект Class, представляющий **класс объекта**.
12. Укажите правила переопределения методов equals(), hashCode() и toString().
- Необходимо переопределять метод Hashcode(), в каждом классе который содержит переопределение метода equals(). 
```
@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (!(o instanceof Money))
        return false;
    Money other = (Money)o;
    boolean currencyCodeEquals = (this.currencyCode == null && other.currencyCode == null)
      || (this.currencyCode != null && this.currencyCode.equals(other.currencyCode));
    return this.amount == other.amount && currencyCodeEquals;
}
```
Контракт у equals следующий
reflexive: объект должен быть равным самому себе.
symmetric: x.equals(y) должен вернуть такой же результат для y.equals(x)
transitive: если x.equals(y) и y.equals(z) значит x.equals(z) будет так же равен предыдущим объектам.
consistent: значение equals()должно изменяться только в том случае, если свойство, содержащееся в equals() измененнно. Без каких либо случайностей.
так же стоит помнить контракт equals и hashCode:
если hashCode(x) == hashCode(y) это еще не значит что x.equals(y) соответственно требуется проверка. но если x.equals(y), то утверждение hashCode(x) == hascCode(y) верно. Несоблюдение данного контракта приведет к нарушению общего договора для Object.hashCode() в последствии из-за чего все коллекции работающие на основе хэшей, не будут работать корректно, такие как HashMap, HashSet, HashTable. toString рекомендуется переопределять для всех подклассов, при этом должен быть читабельным для пользователя.