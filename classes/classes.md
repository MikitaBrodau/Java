1.**Опишите процедуру инициализации полей класса и полей экземпляра класса. Когда инициализируются поля класса, а когда – поля экземпляров класса. Какие значения присваиваются полям по умолчанию? Где еще в классе полям могут быть присвоены начальные значения?**
- Поля класса описываются непосредсвтенно внутри класса и они являются обобщенными. 
Поля экземпляра класса это объект внутри которого могут быть присвоены значения переменных поля класса.
- поля класса иницализируются в самом классе например:
```
class Student{
private int course = 1;
private float  average;
```
- поля экземпляра инициализируются в зависимости от необходимости. один из примеров:
```
public static void main(String[] args){
	Student student = new Student(3) // представим что тут конструктор Average
   	student.setCourse(5) // представим что тут есть сеттер, чтобы мы могли поменять курс студента.
```
- по умолчанию целочисленные переменные получают = 0; строковые = null; булевые = false; с плавающей точкой = 0.0; символьные '\u0000'.
- в конструкторе.
2. **Дайте определение перегрузке методов. Как вы думаете, чем удобна перегрузка методов? Укажите, какие методы могут перегружаться, и какими методами они могут быть перегружены? Можно ли перегрузить методы в базовом и производном классах? Можно ли private метод базового класса перегрузить public методов производного? Можно ли перегрузить конструкторы, и можно ли при перегрузке конструкторов менять атрибуты доступа у конструкторов?**
- Перегрузка методов - это возможность создавать несколько методов с одинаковым названием, но разными входыми параметрами.
- можно создавать конструкторы/методы с разными входными параметрами. в условиях одного наименования всегда ясна исполняемая функция.
- статические методы могут перегружаться нестатическими и наоборот
- В производном классе разрешается перегружать любые видимые методы, кроме конструктора базового класса.
- private методы в родительском классе ограничены зоной видимости и могут использоваться только внутри классса. соответсвтенно дочерний метод без проблем может перегружаться.
- перегрузка конструктора возможна, изменение артрибута доступа в случае перегрузки тоже доступа.
3. **Объясните, что такое раннее и позднее связывание? Перегрузка – это раннее или позднее связывание? Объясните правила, которым следует компилятор при разрешении перегрузки; в том числе, если методы перегружаются примитивными типами, между которыми возможно неявное приведение или ссылочными типами, состоящими в иерархической связи.**
- Раннее связывание - это когда метод, который будет вызван, известен во время компиляции, например, вызов статического метода.А позднее связывание(оно же динамическое) - Позднее связывание - это когда вызов метода может быть осуществлен только во время выполнения и у компилятора нет информации, чтобы проверить корректность такого вызова.
- Перегрузка это пример раннего связывания.
- никакие два метода из одного класса не могут иметь одинаковые сигнатуры(при этом сигнатура не включает в себя возвращаемый параметр). Выбирается наиболее подходящий метод. Расширяющее преобразование примитивов имеет приоритет над автоупоковкой/распоковкой. Сужающее преобразование примитивов автоматически не выполняется. Когда вызывается метод , количество фактических аргументов (и любых явных аргументов типа) и типы аргументов времени компиляции используются во время компиляции для определения сигнатуры метода, который будет вызван.
4. **Объясните, как вы понимаете, что такое неявная ссылка this? В каких методах эта ссылка присутствует, а в каких – нет, и почему?**
- ключевое слово This используется в методах в случае необходимости манипуляции полями класса. не используется в статических методах.
5. **Что такое финальные поля, какие поля можно объявить со спецификатором final? Где можно инициализировать финальные поля?**
- Недоступные для каких-либо изменений после инициализации, все поля с спецификатором Final являются Immutable. использовать спецификатор Final, можно с любым модификатором доступа.
- Финальные поля можно инициализировать внутри классов.
6. **Что такое статические поля, статические финальные поля и статические методы. К чему имеют доступ статические методы? Можно ли перегрузить и переопределить статические методы? Наследуются ли статические методы?**
- Поля данных, объявленные в классе как static, являются общими для всех объектов класса и называются переменными **класса**. static final поля являются константами(глобальными переменными).Такие методы являются методами класса, не привязаны ни к какому объекту и не содержат указателя this на конкретный объект, вызвавший метод.
- Статические методы могут наследоваться, но не могут быть переопределены.
7. **Что такое логические и статические блоки инициализации? Сколько их может быть в классе, в каком порядке они могут быть размещены и в каком порядке вызываются?**
- Логические блоки чаще всего используются в качестве инициализаторов полей, но могут содержать вызовы методов как текущего класса, так и не принадлежащих ему. статический блок используется для инициализации статических переменных, а "обычный"  - для всех остальных.
- Статический блок вызывается только один раз в одном из двух случаев:
`при первом создании объекта этого класса;`
`при первом обращении к статическим членам этого класса.`
не статический блок может использоваться неограниченное колличество раз.
8. **Что представляют собой методы с переменным числом параметров, как передаются параметры в такие методы и что представляет собой такой параметр в методе? Как осуществляется выбор подходящего метода, при использовании перегрузки для методов с переменным числом параметров**
- Метод с переменным числом параметров, подразумевает неоднократную передачу параметра одного типа. Передаются по правилу объявление в сигнатуре метода
`void pachemu (String ... patamu){}` с помощью многоточья. обязательно переменная должна находится в конце передаваемых параметров. Представляет из себя массив соответственно:
``` 
void pachemu (String ... patamu){
	for(int i = 0; i < patamu.length; i++){
    		sout(patamu[i]);// argumenti
    	}
}
```                                    
Метод, который получает аргументы переменной длины, может иметь несколько перегруженных реализаций. Такие реализации отличаются между собой типом получаемых значений.    
9. Чем является класс Object? Перечислите известные вам методы класса  Object, укажите их назначение.
- Класс object является суперклассом, все остальные классы являются производными от объекта object.
- clone, equals, toString, finalize, hashCode, getClass. так же методы для работы с многопоточностью notify, notifyAll, wait
10. Что такое хэш-значение? Объясните, почему два разных объекта могут сгенерировать одинаковые хэш-коды?
-  хеш-код — это целочисленный результат работы метода, которому в качестве входного параметра передан объект(код ячейки памяти в котором находится объект). 
- т.к. хэш-код означается переменной типа int , который равен 4-м байтам, и может помещать числа от -2 147 483 648 до 2 147 483 647. Вероятность возникновения коллизии зависит от используемого алгоритма генерации хеш-кода. Множество объектов мощнее множества хеш-кодов соответственно вероятность колизии растет с количеством объектов.
![](https://eclipsesource.com/wp-content/uploads/2012/09/hashcode-collisions.png)
11. Что такое объект класса Class? Чем использование метода getClass() и последующего сравнения возвращенного значения с Type.class отличается от использования оператора instanceof?
- это производная класса имеющая инициализированные поля.
- InctanceOf проверяет, является ли ссылка слева - экземпляром  типа в правой части, или подтипом. а getClass, возвращает имя класса из которого создан экземпляр.
12. Укажите правила переопределения методов equals(), hashCode() и toString().
- Необходимо переопределять метод Hashcode(), в каждом классе который содержит переопределение метода equals(). Несоблюдение данного контракта приведет к нарушению общего договора для Object.hashCode() в последствии из-за чего все коллекции работающие на основе хэшей, не будут работать корректно, такие как HashMap, HashSet, HashTable. toString рекомендуется переопределять для всех подклассов, при этом должен быть читабельным для пользователя.