1.**Дайте развернутое объяснение трем концепциям ООП.**
 - парадигм у ООП более 3. самые популярные следующие:
  Абстракция — отделение концепции от ее экземпляра;
 -  Полиморфизм — реализация задач одной и той же идеи разными способами;
 -  Наследование — способность объекта или класса базироваться на другом объекте или классе. Это главный механизм для повторного использования кода. Наследственное отношение классов четко определяет их иерархию;
 -  Инкапсуляция — размещение одного объекта или класса внутри другого для разграничения доступа к ним.
 2. **Опишите процедуру инициализации полей класса и полей экземпляра класса. Когда инициализируются поля класса, а когда – поля экземпляров класса. Какие значения присваиваются полям по умолчанию? Где еще в классе полям могут быть присвоены начальные значения?**
 - поля класса описывают состояние класса. Грубо говоря чертеж следуя которому будут создаваться экземпляры класса. Поля экземпляра класса -  это состояние объекта которое ему присвоено по-умолчанию или инициализировано.
 соответственно инициализация происходит на этапе поля класса в случае если указаны их значения. В другом случае инциализация происходит уже непосредственно при создании экземпляра. 	по умолчанию полям в зависимости от типа данных принадлежат следующие значения:
 ```:
 int      => 0
boolean  => false
double   => 0.0
float    => 0.0
char     => \u0000  - нуль-символ, он же ' '
long     => 0
byte     => 0
```
- Начальную инициализацию так же можно задать отдельным блоком кода, он же секция инициализации:
```
{
	a = 4;
    	b = 10;
}
```
 3. **Приведите правила, которым должен следовать компонент java-bean**
 - Класс должен иметь конструктор без параметров, с модификатором доступа public. Такой конструктор позволяет инструментам создать объект без дополнительных сложностей с параметрами.
- Свойства класса должны быть доступны через `get`, `set` и другие методы (так называемые методы доступа), которые должны подчиняться стандартному соглашению об именах. Это легко позволяет инструментам автоматически определять и обновлять содержание bean’ов. Многие инструменты даже имеют специализированные редакторы для различных типов свойств.
- Класс должен быть сериализуем. Это даёт возможность надёжно сохранять, хранить и восстанавливать состояние bean независимым от платформы и виртуальной машины способом.
 - Класс должен иметь переопределенные методы equals(), hashCode() и toString().
 4. **Дайте определение перегрузке методов. Как вы думаете, чем удобна перегрузка методов? Укажите, какие методы могут перегружаться, и какими методами они могут быть перегружены? Можно ли перегрузить методы в базовом и производном классах? Можно ли private метод базового класса перегрузить public методов производного? Можно ли перегрузить конструкторы, и можно ли при перегрузке конструкторов менять атрибуты доступа у конструкторов?**
 - Перегрузка методов - это статический полиморфизм. По сути прием который позволяет использовать одно имя метода с условием того, что входные параметры будут либо разного типа, либо разное колличество.
 - Перегрузка методов удобна тем, что внезависимости от входных параметров, при грамотном пододе к коду, позволит помнить что метод выполняет схожую функцию.
 - Любые методы могут быть перегружены. могут быть перегружены как статическими методами так и обычными методами. При этом если нет различия по входным параметрам и разница только в ключевом слове static - методы не могут быть перегружены.
 - Методы можно переопределять в классе наследнике
 - Переопределять можно любые методы в производном классе кроме финальных. Конструкторы базового класса переопределять так же нельзя. В производном классе разрешается перегружать любые видимые методы.
 - private метод в производном классе невозможно перегрузить, т.к. он находится вне зоны видимости.
 - перегружать конструкторы можно, за исключением переопределения внутри производного класса. Конструктор возможно перегрузить с использованием разных модификаторов доступа при условии разных входных параметров.
5.**Объясните, что такое раннее и позднее связывание? Перегрузка – это раннее или позднее связывание? Объясните правила, которым следует компилятор при разрешении перегрузки; в том числе, если методы перегружаются примитивными типами, между которыми возможно неявное приведение или ссылочными типами, состоящими в иерархической связи.**
- Ранее связывание,  происходит на этапе компиляции. Оно применяется при вызове обычных методов.
Позднее связывание происходит уже на этапе рантайма. Выполняется при вызове виртуальных функций потомка, для определения какой метод будет вызван.
- Перегрузка является ранним связыванием.
- Перегрузка разрешается при соблюдении условий одинаковых имён и разных аргументов.
в случае расширения примитивного типа например от `int` до `long` проблем не будет.
в другом же случае может произойти потеря данных, потому в этом случае может понадобиться явно приведение. в случае с ссылочным типом потребуется явное приведение.
6. ** Объясните, как вы понимаете, что такое неявная ссылка this? В каких методах эта ссылка присутствует, а в каких – нет, и почему?**
- слово Java `this` используется для ссылки на текущий экземпляр метода, на котором он используется. соответственно `this` применяется в контексте конкретного объекта, либо при необходимости использовать другие конструкторы текущего класса в другом конструкторе. в статических методах `this` использовать нельзя. так же используются в случае если имеются переменные с тем же именем. Использоваться может в любых методам для указания на поле конкретного экземпляра класса. 
 7. **Что такое финальные поля, какие поля можно объявить со спецификатором final? Где можно инициализировать финальные поля?**
- Финальные поля - это поля которые имеют неизменное значение(константа). любые поля могут иметь спецификатор final. 
- с помощью непосредственного присваивания (=) значения при объявлении final-поля данных класса;
с помощью конструктора класса. Этот способ подходит только для нестатических неизменных данных. Сначала в классе объявляется поле класса со спецификатором final. Это поле называется пустой константой. Затем эта пустая константа обязательно инициализируется значением в конструкторе класса. Количество перегруженных конструкторов, которые инициализируют пустые константы, может быть любым.
8. **Что такое статические поля, статические финальные поля и статические методы. К чему имеют доступ статические методы? Можно ли перегрузить и переопределить статические методы? Наследуются ли статические методы?**
- Статические поля - глобальная переменная для всех экземпляров класса. В случае с финальным статическим полем - это глобальная неизменная переменная, которая иницализируется только один раз. статический метод принадлежит конкретному классу, использовать поля класса может только статические, не имеет указателя `this` т.к. не может ссылаться на конкретный экземпляр класса.
- Только к статическим переменным класса.
- Перегрузка возможно, однако переорпеделение - нет, т.к. реализация метода зависит только от класса. в случае "переопределения" метод в супер классе и наследнике действуют как разные методы.
- Статический метод наследуется. НО переопределить его нельзя. В этом случае просто создается другой статический метод.
9. **Что такое логические и статические блоки инициализации? Сколько их может быть в классе, в каком порядке они могут быть размещены и в каком порядке вызываются?**
- Логический блок - может инициализировать не статические переменные. Статический - статичиские. Блок это часть код которой заключён в фигурные скобки, может выполнять разные действия
- Статический блок вызывается только один раз. логический блок может вызываться неограниченное кол-во раз. 
- Размещены могут быть в хаотичном порядке. вызываться будут в первую очередь статические.
10.**Что представляют собой методы с переменным числом параметров, как передаются параметры в такие методы и что представляет собой такой параметр в методе? Как осуществляется выбор подходящего метода, при использовании перегрузки для методов с переменным числом параметров?**
- Метод с переменным числом параметров, подразумевает неоднократную передачу параметра одного типа. Передаются по правилу объявление в сигнатуре метода void pachemu `(String ... patamu){}` с помощью многоточья. обязательно переменная должна находится в конце передаваемых параметров, аргумент с переменным числом параметров может быть только один. Представляет из себя массив соответственно:
```
void pachemu (String ... patamu){
	for(int i = 0; i < patamu.length; i++){
    		sout(patamu[i]);// argumenti
    	}
}
```
- Метод, который получает аргументы переменной длины, может иметь несколько перегруженных реализаций. Такие реализации отличаются между собой типом получаемых значений.
11. **Чем является класс Object? Перечислите известные вам методы класса  Object, укажите их назначение.**
- Класс object является суперклассом, все остальные классы являются производными от объекта object.
- clone, equals, toString, finalize, hashCode, getClass. так же методы для работы с многопоточностью notify, notifyAll, wait
12. **Что такое хэш-значение? Объясните, почему два разных объекта могут сгенерировать одинаковые хэш-коды?**
- хеш-код — это целочисленный результат работы метода, которому в качестве входного параметра передан объект(код ячейки памяти в котором находится объект).
- т.к. хэш-код означается переменной типа int , который равен 4-м байтам, и может помещать числа от -2 147 483 648 до 2 147 483 647. Вероятность возникновения коллизии зависит от используемого алгоритма генерации хеш-кода. Множество объектов мощнее множества хеш-кодов соответственно вероятность колизии растет с количеством объектов.
13. **Как вы думаете, для чего используется наследование классов в java-программе? Приведите пример наследования. Как вы думаете, поля и методы, помеченными модификатором доступа private, наследуются?**
- По моему мнению наследование спасает от излишка повторного кода, позволяет увеличить общую читабельность кода.
```
class Dog{
	public void(){sout("Bark :)");
    }
class Bulterier extends Dog{
        public void(){sout("barkIMGONNAKILLYOU");}
        }
```
- private поля и методы, не наследуются.
14. **Укажите, как вызываются конструкторы при создании объекта производного класса? Что в конструкторе класса делает оператор super()? Возможно ли в одном конструкторе использовать операторы super() и this()?**
- Сначала будет вызван конструктор родительского класса.  в конструкторе Super вызывает конструктор родительского класса. Возможно при условии того что с помощью ключевого слова `this` будут инциализированы поля наследника.
```
class Dog{

private int age;
private int weight

   	public Dog(int age, int weight){
    	this.age = age;
    	this.weight = weight;
	{
    
	 public void(){
   	 sout("Bark :)")
   	 }
}
class Bulterier extends Dog{
private Person owner;

	public Bulterier(int age, int weight, Person owner){
        super(age, weight);
        this.owner = owner;
   	bark();
	}
    
        public void(){
        sout("barkIMGONNAKILLYOU");
        }
}
```
15.**Объясните, как вы понимаете утверждения: “ссылка базового класса может ссылаться на объекты своих производных типов” и “объект производного класса может быть использован везде, где ожидается объект его базового типа”. Верно ли обратное и почему?**
- Если например в месте где создается объект базового класса `A a = new B()` соответственно ссылка базового класса ссылается на объект B. Может быть использован где требуется объект базового класса т.к. этот класс производный и имеет все параметры которые имеются у базового класса.
16. **Что такое переопределение методов? Как вы думаете, зачем они нужны? Можно ли менять возвращаемый тип при переопределении методов? Можно ли менять атрибуты доступа при переопределении методов? Можно ли переопределить методы в рамках одного класса?**
- Переопределение метода, это возможность которая позволяет изменить реализацию метода базового класса в дочернем не меняя сигнатуру метода.
- Переопределение необходимо для повышения гибкости разработки а так же повышения читабельности кода, ведь если мы говорим о методе `makeSound()` то у `dog` и `cat` реализация будет отличаться, но суть останется та же.
- при изменении сигнатуры метода - это уже перегрузка.
- артрибуты доступа могут меняться только в случае upcasting'a, т.е. с protected до public;
- Переопределение возможно только в рамках иерархии классов, т.е. базовый и подкласс;
17. **Определите правило вызова переопределенных методов. Можно ли статические методы переопределить нестатическими и наоборот?**
- сигнатура должна быть идентична, в т.ч. должен быть идентичен тип возвращаемого значения.
- статические методы не могут быть переопределены.
18. **Какие свойства имеют финальные методы и финальные классы? Как вы думаете, зачем их использовать?**
- Запрещает переопределение / наследование. 
- В случае необходимости ограничить доступ к классам/методам.
19. **Укажите правила приведения типов при наследовании. Напишите примеры явного и неявного преобразования ссылочных типов. Объясните, какие ошибки могут возникать при явном преобразовании ссылочных типов.**
- Приведение типов может происходить при условии приведении к родительскому классу.
- Приведение типов может так же происходить при нисходящем преобразовании.
- `Parent parent = (Parent) new Child();` явное приведение.
`Parent parent = new Child();` неявное приведение.
- При явном приведении типов может возникнуть RuntimeException, например при попытке явного приведения объекта к типу другого объекта который не состоит в иерархии с первым. При нисходящем образовании можно получить ошибку ClassCastException
20. **Что такое объект класса Class? Чем использование метода getClass() и последующего сравнения возвращенного значения с Type.class отличается от использования оператора instanceof?**
- является родительским классом для всех классов в java. Другими словами, это высший класс java.
- Инстанс проверят принадлежность подкласса к родителю. В то время как getClass возвращает имя класса которому фактически принадлежит созданный объект.
21. **Укажите правила переопределения методов equals(), hashCode() и toString().**
- Необходимо переопределять метод Hashcode(), в каждом классе который содержит переопределение метода equals(). Несоблюдение данного контракта приведет к нарушению общего договора для Object.hashCode() в последствии из-за чего все коллекции работающие на основе хэшей, не будут работать корректно, такие как HashMap, HashSet, HashTable. toString рекомендуется переопределять для всех подклассов, при этом должен быть читабельным для пользователя.
22. **Что такое абстрактные классы и методы? Зачем они нужны? Бывают ли случаи, когда абстрактные методы содержат тело? Можно ли в абстрактных классах определять конструкторы? Могут ли абстрактные классы содержать неабстрактные методы? Можно ли от абстрактных классов создавать объекты и почему?**
- Абстрактный класс - не может иметь экземпляров класса. Метод при этом не имеет реализации. Грубо говоря Абстрактный класс это чертёж чертежей(наследующихся от него подклассов). 
- Они нужны для универсальности, повышения уровня абстракции, если у меня есть `employee` и `client` будет логично что они оба являются `person` но у них свои методы/поля и реализации. 
- Абстрактные методы не могут содержать тело. в этом отношении они схожи с интерфейсами.
- Да, в абстрактных классах можно объявлять конструкторы, соответственно наследники будут его реализовывать. В целом это задается для установки первоначальных значений полям абстрактного класса.
- могут, так же неабстрактные методы могут иметь тело.
- Абстрактные классы призваны предоставлять базовый функционал для классов-наследников. А производные классы уже реализуют этот функционал. Соответственно они не могут иметь экземпляры.
23. **Что такое интерфейсы? Как определить и реализовать интерфейс в java-программе? Укажите спецификаторы, которые приобретают методы и поля, определенные в интерфейсе. Можно ли описывать в интерфейсе конструкторы и создавать объекты? Можно ли создавать интерфейсные ссылки и если да, то на какие объекты они могут ссылаться?**
-  это ссылочный тип в Java. Он схож с классом. Это совокупность абстрактных методов. Класс реализует интерфейс, таким образом наследуя абстрактные методы интерфейса.
- для определения интерфейса необходимо использовать ключевое слово `interface`
реализация происходит при ключевом слове `implements`
- Все методы и переменные неявно объявляются как public. доступные спецификаторы: public, protected, and private
- Описывать конструкторы и создавать объекты в интерфейсе нельзя т.к. он является абстрактным.
- ссылка может указывать на экземпляр любого класса, который реализует объявленный интерфейс. При вызове метода через такую ссылку будет вызываться его реализованная версия, основанная на текущем экземпляре класса
24. **Для чего служит интерфейс Clonable? Как правильно переопределить метод clone() класса Object, для того, что объект мог создавать свои адекватные копии?**
- для создания копии объекта которая не зависит от оригинала. Clonable - это интерфейс маркер, он не содержит ни методов, ни переменных. Интерфейсы маркер просто определяют поведение классов.
- необходимо имплементировать интерфейс Clonable и для создания глубокой копии переопределить метод:
```
	@Override
	public Jesus clone() throws CloneNotSupportedException{
    		Jesus newJesus = (Jesus) super.clone();
            newJesus.setReligion("Buddism");
            return newJesus;
    }
```
25. **Для чего служат интерфейсы Comparable и Comparator? В каких случаях предпочтительнее использовать первый, а когда – второй? Как их реализовать и использовать?**
- Для сравнения, сортировки по необходимым параметрам.
- Первый стоит используется внутри класса, внутри которого объекты сравниваются.
Второй используется для сортировки коллекций, а так же для того чтобы задать порядок организации хранения внутри структуры данных.
- реализуются с помощью соответствующего интерфейса, зачастую comparator выносится в отдельный класс. Используются в зависимости от условия сортировки размер, цена и т.д.
например
```
	Class ClientSortByAmountOfOrders implements Comparator<Client>{
    		@Override
            	public int compare (Client c1, Client c2){
                	return c1.ordersAmount - c2.ordersAmount;
    	}
    }