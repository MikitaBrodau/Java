1.**Дайте развернутое объяснение трем концепциям ООП.**
 -  Полиморфизм — реализация задач одной и той же идеи разными способами;
 -  Наследование — способность объекта или класса базироваться на другом объекте или классе. Это главный механизм для повторного использования кода. Наследственное отношение классов четко определяет их иерархию;
 -  Инкапсуляция — размещение одного объекта или класса внутри другого для разграничения доступа к ним.
 - так же можно выделить  абстракцию — отделение концепции от ее экземпляра;
 2. **Опишите процедуру инициализации полей класса и полей экземпляра класса. Когда инициализируются поля класса, а когда – поля экземпляров класса. Какие значения присваиваются полям по умолчанию? Где еще в классе полям могут быть присвоены начальные значения?**
 - поля класса являются статическими и они описывают состояние класса. Грубо говоря чертеж следуя которому будут создаваться экземпляры класса. Поля экземпляра класса -  это состояние объекта которое ему присвоено по-умолчанию или инициализировано.
 соответственно инициализация происходит на этапе поля класса в случае если указаны их значения. В другом случае инциализация происходит уже непосредственно при создании экземпляра. 	по умолчанию полям в зависимости от типа данных принадлежат следующие значения:
 ```:
 int      => 0
boolean  => false
double   => 0.0
float    => 0.0
char     => \u0000  - нуль-символ, он же ' '
long     => 0
byte     => 0
```
- В Java инициализатор - это блок кода, который не имеет связанного имени или типа данных и размещается вне какого-либо метода, конструктора или другого блока кода.
Java предлагает два типа инициализаторов, статические и экземпляры инициализаторов.:
```
{
	a = 4;
    	b = 10;
}
```
либо через конструктор, `get` и `set`, либо сразу инициализировать в конструктора.
 3. **Приведите правила, которым должен следовать компонент java-bean**
 - Класс должен иметь конструктор без параметров, с модификатором доступа public. Такой конструктор позволяет инструментам создать объект без дополнительных сложностей с параметрами.
- Свойства класса должны быть доступны через `get`, `set` и другие методы (так называемые методы доступа), которые должны подчиняться стандартному соглашению об именах. Это легко позволяет инструментам автоматически определять и обновлять содержание bean’ов. Многие инструменты даже имеют специализированные редакторы для различных типов свойств.
- Класс должен быть сериализуем. Это даёт возможность надёжно сохранять, хранить и восстанавливать состояние bean независимым от платформы и виртуальной машины способом.
- Класс должен иметь переопределенные методы equals(), hashCode() и toString().
 4. **Дайте определение перегрузке методов. Как вы думаете, чем удобна перегрузка методов? Укажите, какие методы могут перегружаться, и какими методами они могут быть перегружены? Можно ли перегрузить методы в базовом и производном классах? Можно ли private метод базового класса перегрузить public методов производного? Можно ли перегрузить конструкторы, и можно ли при перегрузке конструкторов менять атрибуты доступа у конструкторов?**
 - Перегрузка методов - это статический полиморфизм. По сути прием который позволяет использовать одно имя метода с условием того, что входные параметры будут либо разного типа, либо разное колличество.
 - Перегрузка методов удобна тем, что внезависимости от входных параметров, при грамотном пододе к коду, позволит помнить что метод выполняет схожую функцию.
 - Любые методы могут быть перегружены. могут быть перегружены как статическими методами так и обычными методами. При этом если нет различия по входным параметрам и разница только в ключевом слове static - методы не могут быть перегружены.
 - Методы можно переопределять в классе наследнике
 - Переопределять можно любые методы в производном классе кроме финальных. Конструкторы базового класса переопределять так же нельзя. В производном классе разрешается перегружать любые видимые методы.
 - private метод в производном классе невозможно перегрузить, т.к. он находится вне зоны видимости.
 - перегружать конструкторы можно, за исключением переопределения внутри производного класса. Конструктор возможно перегрузить с использованием разных модификаторов доступа при условии разных входных параметров. Если в консрукторе будет выброшено исключение - объект не будет создан.
5.**Объясните, что такое раннее и позднее связывание? Перегрузка – это раннее или позднее связывание? Объясните правила, которым следует компилятор при разрешении перегрузки; в том числе, если методы перегружаются примитивными типами, между которыми возможно неявное приведение или ссылочными типами, состоящими в иерархической связи.**
- Ранее связывание,  происходит на этапе компиляции. Оно применяется при вызове обычных методов.
Позднее связывание происходит уже на этапе рантайма. Выполняется при вызове виртуальных функций потомка, для определения какой метод будет вызван.
- Перегрузка является ранним связыванием.
- Перегрузка разрешается при соблюдении условий одинаковых имён и разных аргументов.
в случае расширения примитивного типа например от `int` до `long` проблем не будет.
в другом же случае может произойти потеря данных, потому в этом случае может понадобиться явно приведение. в случае с ссылочным типом потребуется явное приведение.
6. ** Объясните, как вы понимаете, что такое неявная ссылка this? В каких методах эта ссылка присутствует, а в каких – нет, и почему?**
- слово Java `this` используется для ссылки на текущий экземпляр метода, на котором он используется. соответственно `this` применяется в контексте конкретного объекта, либо при необходимости использовать другие конструкторы текущего класса в другом конструкторе. в статических методах `this` использовать нельзя. так же используются в случае если имеются переменные с тем же именем. Использоваться может в любых методам для указания на поле конкретного экземпляра класса. 
 7. **Что такое финальные поля, какие поля можно объявить со спецификатором final? Где можно инициализировать финальные поля?**
- Финальные поля - это поля которые имеют неизменное значение(константа). любые поля могут иметь спецификатор final. 
- с помощью непосредственного присваивания (=) значения при объявлении final-поля данных класса;
с помощью конструктора класса. Этот способ подходит только для нестатических неизменных данных. Сначала в классе объявляется поле класса со спецификатором final. Это поле называется пустой константой. Затем эта пустая константа обязательно инициализируется значением в конструкторе класса. Количество перегруженных конструкторов, которые инициализируют пустые константы, может быть любым.
8. **Что такое статические поля, статические финальные поля и статические методы. К чему имеют доступ статические методы? Можно ли перегрузить и переопределить статические методы? Наследуются ли статические методы?**
- Статические поля - глобальная переменная для всех экземпляров класса. В случае с финальным статическим полем - это глобальная неизменная переменная, которая иницализируется только один раз. статический метод принадлежит конкретному классу, использовать поля класса может только статические, не имеет указателя `this` т.к. не может ссылаться на конкретный экземпляр класса.
- Только к статическим переменным класса.
- Перегрузка возможно, однако переорпеделение - нет, т.к. реализация метода зависит только от класса. в случае "переопределения" метод в супер классе и наследнике действуют как разные методы.
- Статический метод наследуется. НО переопределить его нельзя. В этом случае просто создается другой статический метод.
- Статический методы могут использовать статические методы других классов.
9. **Что такое логические и статические блоки инициализации? Сколько их может быть в классе, в каком порядке они могут быть размещены и в каком порядке вызываются?**
- Логический блок - может инициализировать не статические переменные. Статический - статичиские. Блок это часть код которой заключён в фигурные скобки, может выполнять разные действия.
- Статический блок вызывается только один раз. логический блок может вызываться неограниченное кол-во раз. 
- Размещены могут быть в хаотичном порядке. вызываться будут в первую очередь статические.
10.**Что представляют собой методы с переменным числом параметров, как передаются параметры в такие методы и что представляет собой такой параметр в методе? Как осуществляется выбор подходящего метода, при использовании перегрузки для методов с переменным числом параметров?**
- Метод с переменным числом параметров, подразумевает неоднократную передачу параметра одного типа. Передаются по правилу объявление в сигнатуре метода void pachemu `(String ... patamu){}` с помощью многоточья. обязательно переменная должна находится в конце передаваемых параметров, аргумент с переменным числом параметров может быть только один. Представляет из себя массив соответственно:
```
void pachemu (String ... patamu){
	for(int i = 0; i < patamu.length; i++){
    		sout(patamu[i]);// argumenti
    	}
}
```
- Метод, который получает аргументы переменной длины, может иметь несколько перегруженных реализаций. Такие реализации отличаются между собой типом получаемых значений.
11. **Чем является класс Object? Перечислите известные вам методы класса  Object, укажите их назначение.**
- Класс object является суперклассом, все остальные классы являются производными от объекта object.
- clone, equals, toString, finalize, hashCode, getClass. так же методы для работы с многопоточностью notify, notifyAll, wait. 
*Метод clone используется для создания **дубликата** объекта.
Метод equals определяет понятие **равенства** объектов, которое основано на сравнении значений, а не ссылок.
Метод finalize запускается непосредственно перед **уничтожением** объекта (§12.6).
Метод getClass возвращает объект Class, представляющий **класс объекта**.
Метод hashCode вместе с методом equals очень полезен в **хэш-таблицах**, таких как java.util.HashMap. hashCode возвращает int значение
Методы wait, notify и notifyAll используются в **параллельном программировании** с использованием потоков.
Метод toString возвращает **строковое представление** объекта.*
12. **Что такое хэш-значение? Объясните, почему два разных объекта могут сгенерировать одинаковые хэш-коды?**
- хеш-код - это код ячейки памяти в котором находится объект.
- т.к. хэш-код означается переменной типа int , который равен 4-м байтам, и может помещать числа от -2 147 483 648 до 2 147 483 647. Вероятность возникновения коллизии зависит от используемого алгоритма генерации хеш-кода. Множество объектов мощнее множества хеш-кодов соответственно вероятность колизии растет с количеством объектов.
13. **Как вы думаете, для чего используется наследование классов в java-программе? Приведите пример наследования. Как вы думаете, поля и методы, помеченными модификатором доступа private, наследуются?**
- По моему мнению наследование спасает от излишка повторного кода, позволяет увеличить общую читабельность кода. позволяет выделить общую логику класса родителя. 
```
class Dog{
	public void(){sout("Bark :)");
    }
class Bulterier extends Dog{
        public void(){sout("barkIMGONNAKILLYOU");}
        }
```
- private поля и методы, не наследуются.
14. **Укажите, как вызываются конструкторы при создании объекта производного класса? Что в конструкторе класса делает оператор super()? Возможно ли в одном конструкторе использовать операторы super() и this()?**
- Сначала будет вызван конструктор родительского класса.  в конструкторе Super вызывает конструктор родительского класса. Возможно при условии того что с помощью ключевого слова `this` будут инциализированы поля наследника.
```
class Dog{

private int age;
private int weight

   	public Dog(int age, int weight){
    	this.age = age;
    	this.weight = weight;
	{
    
	 public void(){
   	 sout("Bark :)")
   	 }
}
class Bulterier extends Dog{
private Person owner;

	public Bulterier(int age, int weight, Person owner){
        super(age, weight);
        this.owner = owner;
   	bark();
	}
    
        public void(){
        sout("barkIMGONNAKILLYOU");
        }
}
```
15.**Объясните, как вы понимаете утверждения: “ссылка базового класса может ссылаться на объекты своих производных типов” и “объект производного класса может быть использован везде, где ожидается объект его базового типа”. Верно ли обратное и почему?**
- Если например в месте где создается объект базового класса `A a = new B()` соответственно ссылка базового класса ссылается на объект B. Может быть использован где требуется объект базового класса т.к. этот класс производный и имеет все параметры которые имеются у базового класса, в этом случае необходимо явно приведение типа.
16. **Что такое переопределение методов? Как вы думаете, зачем они нужны? Можно ли менять возвращаемый тип при переопределении методов? Можно ли менять атрибуты доступа при переопределении методов? Можно ли переопределить методы в рамках одного класса?**
- Это функция, которая позволяет подклассу или дочернему классу предоставлять конкретную реализацию метода, который уже предоставлен одним из его суперклассов или родительских классов. Делает реальным возможность динамичского полиморфизма.
- Переопределение необходимо для повышения гибкости разработки а так же повышения читабельности кода, ведь если мы говорим о методе `makeSound()` то у `dog` и `cat` реализация будет отличаться, но суть останется та же.
- Только в случае если мы будем использовать в качестве возвращаемого аргумента класс т.е.
```
 static class Testing {
        Testing pachemu() {
            return this;
        }
    }
    static class TestingSon extends Testing {
        @Override
        protected TestingSon pachemu() {
            return this;
        }
```
- артрибуты доступа могут меняться только в случае upcasting'a, т.е. с protected до public;
- Переопределение возможно только в рамках иерархии классов, т.е. базовый и подкласс;
17. **Определите правило вызова переопределенных методов. Можно ли статические методы переопределить нестатическими и наоборот?**
- сигнатура должна быть идентична, в т.ч. должен быть идентичен тип возвращаемого значения. вызывается так же как и родитель, можно через ссылку(позднее связывание).
- статические методы не могут быть переопределены.
18. **Какие свойства имеют финальные методы и финальные классы? Как вы думаете, зачем их использовать?**
- Делает класс Immutable, соответственно запрещает переопределение / наследование. 
- В случае необходимости ограничить доступ к классам/методам.
19. **Укажите правила приведения типов при наследовании. Напишите примеры явного и неявного преобразования ссылочных типов. Объясните, какие ошибки могут возникать при явном преобразовании ссылочных типов.**
- Приведение типов может происходить при условии приведении к родительскому классу.
- Приведение типов может так же происходить при нисходящем преобразовании.
- `Parent parent = (Parent) new Child();` явное приведение.
`Parent parent = new Child();` неявное приведение.
- При явном приведении типов может возникнуть RuntimeException, например при попытке явного приведения объекта к типу другого объекта который не состоит в иерархии с первым. При нисходящем образовании можно получить ошибку ClassCastException
20. **Что такое объект класса Class? Чем использование метода getClass() и последующего сравнения возвращенного значения с Type.class отличается от использования оператора instanceof?**
- Экземпляры класса Class представляют классы и интерфейсы в запущенном приложении Java. Перечисление - это разновидность класса, а аннотация - это разновидность интерфейса. Каждый массив также принадлежит к классу, который отражается как объект Class, который используется всеми массивами с одним и тем же типом элемента и числом измерений. Примитивные типы Java (boolean, byte, char, short, int, long, float и double) и ключевое слово void также представлены как объекты класса.
- Инстанс проверят принадлежность подкласса к родителю. В то время как getClass возвращает класс на этапе рантайма который принадлежит к объекту.
21. **Укажите правила переопределения методов equals(), hashCode() и toString().**
- Необходимо переопределять метод Hashcode(), в каждом классе который содержит переопределение метода equals(). 
```
@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (!(o instanceof Money))
        return false;
    Money other = (Money)o;
    boolean currencyCodeEquals = (this.currencyCode == null && other.currencyCode == null)
      || (this.currencyCode != null && this.currencyCode.equals(other.currencyCode));
    return this.amount == other.amount && currencyCodeEquals;
}
```
Контракт у equals следующий
reflexive: объект должен быть равным самому себе.
symmetric: x.equals(y) должен вернуть такой же результат для y.equals(x)
transitive: если x.equals(y) и y.equals(z) значит x.equals(z) будет так же равен предыдущим объектам.
consistent: значение equals()должно изменяться только в том случае, если свойство, содержащееся в equals() измененнно. Без каких либо случайностей.
так же стоит помнить контракт equals и hashCode:
если hashCode(x) == hashCode(y) это еще не значит что x.equals(y) соответственно требуется проверка. но если x.equals(y), то утверждение hashCode(x) == hascCode(y) верно. 
Несоблюдение данного контракта приведет к нарушению общего договора для Object.hashCode() в последствии из-за чего все коллекции работающие на основе хэшей, не будут работать корректно, такие как HashMap, HashSet, HashTable. toString рекомендуется переопределять для всех подклассов, при этом должен быть читабельным для пользователя.
22. **Что такое абстрактные классы и методы? Зачем они нужны? Бывают ли случаи, когда абстрактные методы содержат тело? Можно ли в абстрактных классах определять конструкторы? Могут ли абстрактные классы содержать неабстрактные методы? Можно ли от абстрактных классов создавать объекты и почему?**
- Абстрактный класс - не может иметь экземпляров класса. Метод при этом не имеет реализации. Грубо говоря Абстрактный класс это чертёж чертежей(наследующихся от него подклассов). Абстрактный класс помечается в Java модификатором `abstract` `abstract public smth` 
- Они нужны для универсальности, повышения уровня абстракции, если у меня есть `employee` и `client` будет логично что они оба являются `person` но у них свои методы/поля и реализации. 
- Абстрактные методы не могут содержать тело. в этом отношении они схожи с интерфейсами.
- Да, в абстрактных классах можно объявлять конструкторы, соответственно наследники будут его реализовывать. В целом это задается для установки первоначальных значений полям абстрактного класса.
- могут, так же неабстрактные методы должны иметь иметь тело.
- Абстрактные классы призваны предоставлять базовый функционал для классов-наследников. А производные классы уже реализуют этот функционал. Соответственно они не могут иметь экземпляры.
23. **Что такое интерфейсы? Как определить и реализовать интерфейс в java-программе? Укажите спецификаторы, которые приобретают методы и поля, определенные в интерфейсе. Можно ли описывать в интерфейсе конструкторы и создавать объекты? Можно ли создавать интерфейсные ссылки и если да, то на какие объекты они могут ссылаться?**
-  это ссылочный тип в Java. Он схож с классом. Это совокупность абстрактных методов. Класс реализует интерфейс, таким образом наследуя абстрактные методы интерфейса.
- для определения интерфейса необходимо использовать ключевое слово `interface`
реализация происходит при ключевом слове `implements`
- Все методы и переменные неявно объявляются как public. доступные спецификаторы: public, protected, and private
- Описывать конструкторы и создавать объекты в интерфейсе нельзя т.к. он является абстрактным.
- ссылка может указывать на экземпляр любого класса, который реализует объявленный интерфейс. При вызове метода через такую ссылку будет вызываться его реализованная версия, основанная на текущем экземпляре класса
- так же в интерфейсе могут быть default методы, которые могут иметь некоторую базовую реализацию при этом  не является обязательным обеспечить реализацию методов по умолчанию.
- так же есть и статические методы, которые работают по принципу статических методов в классах. Они могут вызываться исключительно с помощью названия интерфейсов. Переопределять их поведение в классе реализующем интерфейс - нельзя. в таком случае это будет просто статический метод класса.
24. **Для чего служит интерфейс Clonable? Как правильно переопределить метод clone() класса Object, для того, что объект мог создавать свои адекватные копии?**
- для создания копии объекта которая не зависит от оригинала. Clonable - это интерфейс маркер, он не содержит ни методов, ни переменных. Интерфейсы маркер просто определяют поведение классов.
- необходимо имплементировать интерфейс Clonable и для создания глубокой копии переопределить метод:
```
	@Override
	public Jesus clone() throws CloneNotSupportedException{
    		Jesus newJesus = (Jesus) super.clone();
            newJesus.setReligion("Buddism");
            return newJesus;
    }
```
25. **Для чего служат интерфейсы Comparable и Comparator? В каких случаях предпочтительнее использовать первый, а когда – второй? Как их реализовать и использовать?**
- Для сравнения, сортировки по необходимым параметрам.
- Первый стоит используется внутри класса, внутри которого объекты сравниваются.
Второй используется для сортировки коллекций, а так же для того чтобы задать порядок организации хранения внутри структуры данных.
- реализуются с помощью соответствующего интерфейса, зачастую comparator выносится в отдельный класс. Используются в зависимости от условия сортировки размер, цена и т.д.
например
```
	Class ClientSortByAmountOfOrders implements Comparator<Client>{
    		@Override
            	public int compare (Client c1, Client c2){
                	return c1.ordersAmount - c2.ordersAmount;
    	}
    }
```
----------------------------------------------------
Generic classes and Interfaces, Enums
1. **Что такое перечисления в Java. Как объявить перечисление? Чем являются элементы перечислений? Кто и когда создает экземпляры перечислений?**
- Перечисления представляют набор логически связанных констант. Объявление перечисления происходит с помощью оператора enum, после которого идет название перечисления. 	Элементы перечесления являются константами перечисления.
- Экземпляры перечеслений создаются с помощью вызова при указании имени класса enum.
2. **Можно ли самостоятельно создать экземпляр перечисления? А ссылку типа перечисления? Как сравнить, что в двух переменных содержится один и тот же элемент перечисления и почему именно так?**
- Можно создать экземпляр с помощь обращения к enum классу.
- Можно, например у нас `enum Summer { WINTER,SPRING,SUMMER,AUTUMN}` 
соответственно мы можем сделать следующее `Summer summer = Summer.SUMMER;`
- С помощью метода equals который будет проверять идентичность. Либо compareTo. т.к. enum имплементирует интерфейс Comparable. так же есть возможность сравнивать с помощью оператора ==.
3. **Что такое анонимные классы?**
- Анонимный класс позволяет разово изменить реализацию объекта. Его возможно применить при использовании создания объекта, либо интерфейса, либо абстрактного класса.
```
	SomeInterface  someInterface = new SomeInterface(){
    						@Override
                            public void scream(){
                            sout("AGH");
                            }
                       };
	someInterface.scream();
    	Animal animal =  new Animal(){
        	@Override
           	public void madDog(){
            	sout("WHOOWHOWHOWOHOWHOW");
                }
            };
	animal.madDog();
output:
AGH
WHOOWHOWHOWOHOWHOW
```
4. **Что такое параметризованные классы? Для чего они необходимы? Приведите пример параметризованного класса и пример создания объекта параметризованного класса? Объясните, ссылки какого типа могут ссылаться на объекты параметризованных классов? Можно ли создать объект, параметризовав его примитивным типом данных?**
- Дженерики работают только с объектами, соответственно можно создать параметризированный класс напримере
```
public class Trash<T>{
	private List<T> list = new ArrayList();
   	public Trash(List<T> list){
    	this.list = list.clone();
        }
}
```
- Дженерики позволяют повысить безопасность программы, за счёт строгой типизации данных. Делают collection framework намного удобнее, например если необходимо передать лист объектов, нет необходимости каждый раз использовать inctanceOf чтобы определить принадлежность объекта к необходимому типу.
- ссылки любого определенного типа, или к примеру подкласса `Trash< U extends TV>` или выше родительского `Trash< U super TV>`
- примитивным типом данных - нет, но оболочкой возможно Integer, Double, Charactrer e.t.c
----------------------------------------------------
Exceptions and Errors
1. **Что для программы является исключительной ситуацией? Какие способы обработки ошибок в программах вы знаете?**
- некая незапланированная ситуация, которая произошла при работе программы.любая ошибка или исключение является объектом Способы обработок выглядят обычно как блоки `try`,`catch` и `finally`, либо "броском" исключения
2. **? Что значит “программа выбросила исключение”? Опишите ситуации, когда исключения выбрасываются виртуальной машиной(автоматически), и когда необходимо их выбрасывать вручную?**
- Исключение для java это объект, который опишет возникее исключение.
- исключения делятся на unchecked(ошибки которые могут произойти буквально в любом месте) и checked. В случае checked необходимо делать это вручную, по иерархии будут относиться следующие классы ReflectiveOperationException, SQLException, IOException.
3. **Приведите иерархию классов-исключений, делящую исключения на проверяемые и непроверяемые. В чем особенности проверяемых и непроверяемых исключений?**
- Иерархия начинается с класса Throwable -> Error\Exception. Все что относится к классу error является непроверяемым исключением VirtualMachineError/ThreadDeath/OutOfMemmory etc. В Exception, же таковым является класс RuntimeExcepion. Далее Exception класс содержит классы ReflectiveOperationExceptioni, SQLException, IOException которые являются проверяемыми.
- Проверяемые исключение должны быть обязательно обработано с помощью блоков `try`,`catch` и `finally`. Непроверяемые же исключения автоматически создаются и обрабатываются исполняющей средой JVM. Но их так же при желании можно обработать с помощью `try`,`catch` и `finally`.
4. **Объясните работу оператора try-catch-finally. Когда данный оператор следует использовать? Сколько блоков catch может соответствовать одному блоку try? Можно ли вкладывать блоки try друг в друга, можно ли вложить блок try в catch или finally? Как происходит обработка исключений, выброшенных внутренним блоком try, если среди его блоков catch нет подходящего? Что называют стеком операторов try? Как работает блок try с ресурсами.**
- Оператора работает на подобии попробуй! не получилось? тогда лови и закончим. получилось? все равно закончим. То есть блок `try` пробует выполнить действие которое потенциально может вызвать ошибку. Блок `catch` эту ошибку обрабатывает. Блок `finally` завешающий, которые выполняется внезависимости от успеха в предыдущих блоках.
- Данный оператор следует использовать при обработке checked исключений. так же есть возможность обрабатывать любые ошибки т.е. с классом VirtualMachineError/ThreadDeath -> Error -> Throwable.
- один и больше.
- Да, в блок `try` можно вложить другие блоки `try`. так же и в `catch` и `finally`
- Компилятор в этом случае не позволит оставить блок без подходящего исключения.
- Стек оператора `try`, подрузумевает за собой unwinding, раскрутку, то есть если в текущем блоке `try` не обработана ошибка, то он переходит к предыдущему блоку `try` и так до тех пор пока в одном из них не будет обработано исключение.
- Оператор `try` c ресурсами позволяет объявить и проинициализировать ресурс (в круглых скобках после оператора `try`), создав переменной ресурса локальный контекст в блоке try. По завершении этого блока переменная удаляется, а значит и ресурс автоматически закрывается.
- так же можно использовать блок `try` `finally` при условии что исключение указывается в сигнатуре метода и пробрасывается вверх.
5. **Укажите правило расположения блоков catch в зависимости от типов перехватываемых исключений. Может ли перехваченной исключение быть сгенерировано снова, и, если да, то как и кто в этом случае будет обрабатывать повторно сгенерированное исключение? Может ли блок catch выбрасывать иные исключения, и если да, то опишите ситуацию, когда это может быть необходимо.**
- расположение блоков catch должно соответствовать их ирерархии, например RunTimeException не может стоять впереди блока ArithmeticException.
- Только в случае если оно было нарочно сгенирировано. В этом случае требуется повторно обработать его вложенными try/catch.
- Можно в  `catch` указать throw e после чего проброситься вверх и на уровне выше будет необходимость обработать исключение.
6. **Когда происходит вызов блока finally? Существуют ли ситуации, когда блок finally не будет вызван? Может ли блок finally выбрасывать исключений? Может ли блок finally выполнится дважды?**
- вызов блока finally происходит в любом случае вне зависимости от блоков `try` `catch`. 
- в случае если в результате исключения jvm упадет или если вызван System.exit();
или любые другие аварийные завершения до окончательной отработки блоков `try` `catch`.
- может их пробросить выше
- два раза подряд - нет. выполнится в разных блоках `try` - да.
